% Base case: If the board is empty, pick a random column
minimax(D, Board, M, S, U) :-
    is_empty(Board),                     
    random_int_1n(7, S),                 
    !.

% If valid moves exist, recursively determine the best move
minimax(D, Board, M, S, U) :-
    D2 is D + 1,
    valid_moves(Board, Moves),  
    Moves \= [],              
    best(D2, Board, M, Moves, S, U),  
    !.

% If no moves are available, return the utility value
minimax(D, Board, M, S, U) :-
    utility(Board, U),
    !.

%--------------------------------------
% Finding the Best Move
%--------------------------------------

% If only one move left
best(D, Board, M, [Col], S, U) :-
    move(Board, Col, M, NewBoard),   
    switch_player(M, Opponent),    
    minimax(D, NewBoard, Opponent, _S, U),  
    S = Col,
    !.

% If multiple moves exist, evaluate each recursively
best(D, Board, M, [Col|Rest], S, U) :-
    move(Board, Col, M, NewBoard),  
    switch_player(M, Opponent),
    minimax(D, NewBoard, Opponent, _S, U1),  
    best(D, Board, M, Rest, S2, U2),  
    better(D, M, Col, U1, S2, U2, S, U).  

%--------------------------------------
% Choosing the Best Move
%--------------------------------------

better(D, max, S1, U1, S2, U2, S, U) :-
    U1 > U2, S = S1, U = U1, !.
better(D, min, S1, U1, S2, U2, S, U) :-
    U1 < U2, S = S1, U = U1, !.
better(_, _, S1, U1, S2, U2, S, U) :-
    U1 == U2, random_int_1n(10, R), better2(D, R, S1, U1, S2, U2, S, U), !.
better(_, _, _, _, S2, U2, S, U) :- S = S2, U = U2, !.

better2(_, R, S1, U1, S2, U2, S, U) :- R < 6, S = S1, U = U1, !.
better2(_, _, S1, U1, S2, U2, S, U) :- S = S2, U = U2, !.
